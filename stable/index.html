<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>NetalignUtils documentation · NetalignUtils</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>NetalignUtils</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li class="current"><a class="toctext" href="index.html">NetalignUtils documentation</a><ul class="internal"><li class="toplevel"><a class="toctext" href="#Introduction-1">Introduction</a></li><li class="toplevel"><a class="toctext" href="#Installation-1">Installation</a></li><li class="toplevel"><a class="toctext" href="#Types-1">Types</a></li><li class="toplevel"><a class="toctext" href="#Functions-1">Functions</a></li><li><a class="toctext" href="#Dynamic-networks-1">Dynamic networks</a></li><li><a class="toctext" href="#Static-networks-1">Static networks</a></li><li><a class="toctext" href="#Alignments-1">Alignments</a></li><li><a class="toctext" href="#Matrices-1">Matrices</a></li><li><a class="toctext" href="#Network-measures-1">Network measures</a></li><li><a class="toctext" href="#Network-generation-1">Network generation</a></li><li><a class="toctext" href="#Randomization-1">Randomization</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href="index.html">NetalignUtils documentation</a></li></ul><a class="edit-page" href="https://github.com/vvjn/NetalignUtils.jl/blob/master/docs/src/index.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>NetalignUtils documentation</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="NetalignUtils-documentation-1" href="#NetalignUtils-documentation-1">NetalignUtils documentation</a></h1><h1><a class="nav-anchor" id="Introduction-1" href="#Introduction-1">Introduction</a></h1><p>NetalignUtils.jl contains function relevant to network alignment, including function to read/write static and dynamic networks, and other utility functions to deal with static and dynamic networks.</p><h1><a class="nav-anchor" id="Installation-1" href="#Installation-1">Installation</a></h1><p>NetalignUtils can be installed as follows.</p><pre><code class="language-julia">Pkg.add(&quot;NetalignUtils&quot;)</code></pre><h1><a class="nav-anchor" id="Types-1" href="#Types-1">Types</a></h1><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NetalignUtils.DynamicNetwork" href="#NetalignUtils.DynamicNetwork"><code>NetalignUtils.DynamicNetwork</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">immutable DynamicNetwork
    G :: SparseMatrixCSC{Events,Int}
    nodes :: Vector
end</code></pre><p>A <code>DynamicNetwork</code> is a sparse matrix of <code>Events</code> and a list of nodes. <code>G</code> is assumed to be symmetric, unless specified otherwise. The <code>Events</code> structure is defined in the NetalignMeasures.jl package (it is a list of timestamps, where a timestamp is a tuple (start_time, end_time).</p></div><a class="source-link" target="_blank" href="https://github.com/vvjn/NetalignUtils.jl/blob/c6e705502cbe0ac61187665fa1fa449dcac3317a/src/types.jl#L26-L36">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NetalignUtils.Network" href="#NetalignUtils.Network"><code>NetalignUtils.Network</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">immutable Network
    G :: SparseMatrixCSC{Int,Int}
    nodes :: Vector
end</code></pre><p>A <code>Network</code> is a sparse matrix and a list of nodes. <code>G</code> is assumed to be symmetric, unless specified otherwise.</p></div><a class="source-link" target="_blank" href="https://github.com/vvjn/NetalignUtils.jl/blob/c6e705502cbe0ac61187665fa1fa449dcac3317a/src/types.jl#L5-L13">source</a></section><h1><a class="nav-anchor" id="Functions-1" href="#Functions-1">Functions</a></h1><h2><a class="nav-anchor" id="Dynamic-networks-1" href="#Dynamic-networks-1">Dynamic networks</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NetalignUtils.readeventlist" href="#NetalignUtils.readeventlist"><code>NetalignUtils.readeventlist</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">readeventlist(fd::IO; &lt;keyword args&gt;)
readeventlist(file::AbstractString; &lt;keyword args&gt;) -&gt; SparseMatrixCSC{Events}, node list</code></pre><p>Read list of events from file returns undirected dynamic network represented as sparse matrix. An event is an interaction between two nodes from start time to stop time.</p><p><strong>Keyword arguments</strong></p><ul><li><p><code>symmetric=true</code> : If false, only fill the top right triangle, else make resulting matrix symmetric.</p></li><li><p><code>header=false</code> : If true, ignore first line.</p></li><li><p><code>sortby=nothing</code>: If not <code>nothing</code>, sort nodes w.r.t this function (<code>by</code> argument in <code>sort</code>).</p></li><li><p><code>format=:timefirst</code> : If <code>format=:timefirst</code>, each line has format (<code>start_time stop_time node1 node2</code>).   If <code>format=:nodefirst</code>, each line has format (<code>node1 node2 start_time stop_time</code>).</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/vvjn/NetalignUtils.jl/blob/c6e705502cbe0ac61187665fa1fa449dcac3317a/src/iodynet.jl#L3-L16">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NetalignUtils.writeeventlist" href="#NetalignUtils.writeeventlist"><code>NetalignUtils.writeeventlist</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">writeeventlist(fd::IO, dy::DynamicNetwork; &lt;keyword args&gt;)
writeeventlist(file::AbstractString, dy::DynamicNetwork; &lt;keyword args&gt;)</code></pre><p>Write list of events to file from undirected dynamic network represented as sparse matrix. An event is an interaction between two nodes from start time to stop time.</p><p><strong>Keyword arguments</strong></p><ul><li><p><code>format=:timefirst</code> : If <code>format=:timefirst</code>, each line has format (<code>start_time stop_time node1 node2</code>).   If <code>format=:nodefirst</code>, each line has format (<code>node1 node2 start_time stop_time</code>).</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/vvjn/NetalignUtils.jl/blob/c6e705502cbe0ac61187665fa1fa449dcac3317a/src/iodynet.jl#L65-L75">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NetalignUtils.events2dynet" href="#NetalignUtils.events2dynet"><code>NetalignUtils.events2dynet</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">events2dynet(I, J, V, n, nodes; symmetric=true) -&gt; SparseMatrixCSC{Events}, nodes</code></pre><p>Similar to <code>sparse</code>, given indices and values, create an dynamic network.</p><p><strong>Arguments</strong></p><ul><li><p><code>n</code> : # of nodes in network</p></li><li><p><code>I</code>,<code>J</code>: indices</p></li><li><p><code>V</code> : vector of <code>Events</code></p></li><li><p><code>symmetric=true</code> : If true, make the sparse matrix symmetric.</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/vvjn/NetalignUtils.jl/blob/c6e705502cbe0ac61187665fa1fa449dcac3317a/src/dynet.jl#L19-L30">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NetalignUtils.snapshots2dynet" href="#NetalignUtils.snapshots2dynet"><code>NetalignUtils.snapshots2dynet</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">snapshots2dynet(snaps::Vector{Network};
          symmetric=false,sortby=nothing)</code></pre><p>Converts a vector of networks (i.e. temporal snapshots) into a dynamic network with event duration 1 and time starting at 0.</p></div><a class="source-link" target="_blank" href="https://github.com/vvjn/NetalignUtils.jl/blob/c6e705502cbe0ac61187665fa1fa449dcac3317a/src/dynet.jl#L40-L47">source</a></section><h2><a class="nav-anchor" id="Static-networks-1" href="#Static-networks-1">Static networks</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NetalignUtils.readgw" href="#NetalignUtils.readgw"><code>NetalignUtils.readgw</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">readgw(fd::IO)
readgw(file::AbstractString) -&gt; SparseMatrixCSC, node list</code></pre><p>Reads LEDA format file describing a network. Outputs an undirected network. An example of a LEDA file is in the examples/ directory.</p></div><a class="source-link" target="_blank" href="https://github.com/vvjn/NetalignUtils.jl/blob/c6e705502cbe0ac61187665fa1fa449dcac3317a/src/ionet.jl#L17-L23">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NetalignUtils.readedgelist" href="#NetalignUtils.readedgelist"><code>NetalignUtils.readedgelist</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">readedgelist(fd::IO; header=false)
readedgelist(file::AbstractString; header=false) -&gt; SparseMatrixCSC, node list</code></pre><p>Read list of edges and output undirected network</p></div><a class="source-link" target="_blank" href="https://github.com/vvjn/NetalignUtils.jl/blob/c6e705502cbe0ac61187665fa1fa449dcac3317a/src/ionet.jl#L51-L56">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NetalignUtils.writeedgelist" href="#NetalignUtils.writeedgelist"><code>NetalignUtils.writeedgelist</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">writeedgelist(fd::IO, st::Network; prefix=&quot;&quot;,suffix=&quot;&quot;)
writeedgelist(file::AbstractString, st::Network; prefix=&quot;&quot;,suffix=&quot;&quot;)</code></pre><p>Write network to file as list of edges.</p><ul><li><p><code>prefix</code>,<code>suffix</code> : Prefix and suffix to each line.</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/vvjn/NetalignUtils.jl/blob/c6e705502cbe0ac61187665fa1fa449dcac3317a/src/ionet.jl#L90-L97">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NetalignUtils.writegw" href="#NetalignUtils.writegw"><code>NetalignUtils.writegw</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">writegw(fd::IO, st::Network)
writegw(file::AbstractString, st::Network)</code></pre><p>Write undirected network to file as LEDA format.</p></div><a class="source-link" target="_blank" href="https://github.com/vvjn/NetalignUtils.jl/blob/c6e705502cbe0ac61187665fa1fa449dcac3317a/src/ionet.jl#L114-L119">source</a></section><h2><a class="nav-anchor" id="Alignments-1" href="#Alignments-1">Alignments</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NetalignUtils.nodecorrectness" href="#NetalignUtils.nodecorrectness"><code>NetalignUtils.nodecorrectness</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">nodecorrectness(f::AbstractVector{Int},
                nodes1::AbstractVector,nodes2::AbstractVector) -&gt; nc</code></pre><p>Calculates node correctness when given an alignment.</p><p><strong>Arguments</strong></p><ul><li><p><code>f</code> : Alignment between nodes1 and nodes2. <code>f[i]</code> describes the aligned</p></li></ul><p>node pairs <code>nodes1[i]</code> and <code>nodes2[f[i]]</code>. Thus, <code>f</code> describes <code>length(f)</code> aligned node pairs.</p><ul><li><p><code>nodes1</code>,<code>nodes2</code> : Node sets that <code>f</code> desribes the alignment of.</p></li></ul><p><strong>Output</strong></p><ul><li><p><code>nc</code> : Node correctness between 0 and 1.</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/vvjn/NetalignUtils.jl/blob/c6e705502cbe0ac61187665fa1fa449dcac3317a/src/utils.jl#L6-L20">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NetalignUtils.readaln" href="#NetalignUtils.readaln"><code>NetalignUtils.readaln</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">readaln(file::AbstractString, nodes1::Vector,
         nodes2::Vector, flip=false)</code></pre><p>Read alignment file for pairwise network alignment.  Each line will contain a node pair, with the first node from nodes1, and the second node from nodes2.  Returns permutation from nodes1 to nodes2 corresponding to the node pairs (so need length(nodes1) &lt;= length(nodes2)) If flip=true, then returns permutation from nodes2 to nodes1, (so need length(nodes2) &lt;= length(nodes1)) where first node in each line is from nodes2, and the second node is from nodes1.</p></div><a class="source-link" target="_blank" href="https://github.com/vvjn/NetalignUtils.jl/blob/c6e705502cbe0ac61187665fa1fa449dcac3317a/src/ioaln.jl#L26-L37">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NetalignUtils.writealn" href="#NetalignUtils.writealn"><code>NetalignUtils.writealn</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">writealn(fd::IO, nodes1::AbstractVector, nodes2::AbstractVector)
writealn(file::AbstractString, nodes1::AbstractVector, nodes2::AbstractVector)</code></pre><p>Write alignment to file</p></div><a class="source-link" target="_blank" href="https://github.com/vvjn/NetalignUtils.jl/blob/c6e705502cbe0ac61187665fa1fa449dcac3317a/src/ioaln.jl#L90-L95">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NetalignUtils.readseeds" href="#NetalignUtils.readseeds"><code>NetalignUtils.readseeds</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">readseeds(file::AbstractString,
          nodes1::AbstractVector,
          nodes2::AbstractVector) -&gt; Matrix{Int} : n x 2</code></pre><p>Outputs n x 2 matrix of node indices associates with nodes1 and nodes2</p></div><a class="source-link" target="_blank" href="https://github.com/vvjn/NetalignUtils.jl/blob/c6e705502cbe0ac61187665fa1fa449dcac3317a/src/ioaln.jl#L3-L10">source</a></section><h2><a class="nav-anchor" id="Matrices-1" href="#Matrices-1">Matrices</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NetalignUtils.readlistmat" href="#NetalignUtils.readlistmat"><code>NetalignUtils.readlistmat</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">readlistmat(fd::IO, nodes1::Vector, nodes2::Vector; &lt;keyword arguments&gt;)
readlistmat(file::AbstractString, nodes1::Vector, nodes2::Vector; &lt;keyword arguments&gt;)</code></pre><p>Reads a numerical matrix stored in list format, where the first and second columns correspond to string vectors nodes1 and nodes2, respectively. E.g.</p><pre><code class="language-none">nodeA1 nodeA2 4.5
nodeB1 nodeB2 3.4
nodeA1 nodeB2 0.3
nodeB1 nodeA2 0.6</code></pre><p>Returns a dense matrix by default. Set keyword option <code>dense=false</code> to return a sparse matrix.</p><p><strong>Arguments</strong></p><ul><li><p><code>fd</code>,<code>file</code> : file name or file I/O</p></li><li><p><code>nodes1</code>,<code>nodes1</code> : node vectors corresponding to 1st and 2nd columns</p></li></ul><p><strong>Keyword arguments</strong></p><ul><li><p><code>header=false</code> : set to true to ignore first line</p></li><li><p><code>ignore=false</code> : set to true to ignore nodes in file that is not in nodes1 or nodes2</p></li><li><p><code>dense=true</code> : set to false to return sparse matrix</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/vvjn/NetalignUtils.jl/blob/c6e705502cbe0ac61187665fa1fa449dcac3317a/src/iomatrix.jl#L3-L27">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NetalignUtils.readlistmat!" href="#NetalignUtils.readlistmat!"><code>NetalignUtils.readlistmat!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">readlistmat!(fd::IO, B::AbstractMatrix, nodes1::Vector, nodes2::Vector; &lt;keyword arguments&gt;)
readlistmat!(file::AbstractString, B::AbstractMatrix, nodes1::Vector, nodes2::Vector; &lt;keyword arguments&gt;)</code></pre><p>Same as <a href="index.html#NetalignUtils.readlistmat"><code>readlistmat</code></a> but stores the result in B.</p></div><a class="source-link" target="_blank" href="https://github.com/vvjn/NetalignUtils.jl/blob/c6e705502cbe0ac61187665fa1fa449dcac3317a/src/iomatrix.jl#L58-L63">source</a></section><h2><a class="nav-anchor" id="Network-measures-1" href="#Network-measures-1">Network measures</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NetalignUtils.readgdv" href="#NetalignUtils.readgdv"><code>NetalignUtils.readgdv</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">readgdv(fd::IO, nodes::AbstractVector)
readgdv(file::AbstractString, nodes::AbstractVector)</code></pre><p>Reads the .ndump2 file format that contains (static or dynamic) graphlet counts, outputted by GraphCrunch1 (ncount program in http://www0.cs.ucl.ac.uk/staff/natasa/graphcrunch/index.html), or Graphcrunch2 (http://www0.cs.ucl.ac.uk/staff/natasa/graphcrunch2/index.html), or the dynamic graphlets counting code (https://www3.nd.edu/~cone/DG/).</p><p>Graphlets are small, connected, induced sub-graphs of a network (Przulj N, Corneil DG, Jurisica I: Modeling Interactome, Scale-Free or Geometric?, Bioinformatics 2004, 20(18):3508-3515.), similar to network motifs.</p></div><a class="source-link" target="_blank" href="https://github.com/vvjn/NetalignUtils.jl/blob/c6e705502cbe0ac61187665fa1fa449dcac3317a/src/iomeasures.jl#L3-L17">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NetalignUtils.writegdv" href="#NetalignUtils.writegdv"><code>NetalignUtils.writegdv</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">writegdv(fd::IO, X::AbstractMatrix, nodes::AbstractVector)
writegdv(file::AbstractString, X::AbstractMatrix, nodes::AbstractVector)</code></pre><p>Writes to graphlets file format. See <a href="index.html#NetalignUtils.readgdv"><code>readgdv</code></a>.</p></div><a class="source-link" target="_blank" href="https://github.com/vvjn/NetalignUtils.jl/blob/c6e705502cbe0ac61187665fa1fa449dcac3317a/src/iomeasures.jl#L29-L34">source</a></section><h2><a class="nav-anchor" id="Network-generation-1" href="#Network-generation-1">Network generation</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NetalignUtils.SFGD" href="#NetalignUtils.SFGD"><code>NetalignUtils.SFGD</code></a> — <span class="docstring-category">Type</span>.</div><div><p>Scale-free gene duplication</p><ul><li><p><code>p</code></p></li><li><p><code>q</code></p></li><li><p><code>arrival</code> : node arrival function (:quad, :linear, :exp, :constant)</p></li></ul><p>Vazquez, Alexei and Flammini, Alessandro and Maritan, Amos and Vespignani, Alessandro 2003 Modeling of protein interaction networks Complexus 1 38–44</p></div><a class="source-link" target="_blank" href="https://github.com/vvjn/NetalignUtils.jl/blob/c6e705502cbe0ac61187665fa1fa449dcac3317a/src/generators.jl#L213-L221">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NetalignUtils.GEOGD" href="#NetalignUtils.GEOGD"><code>NetalignUtils.GEOGD</code></a> — <span class="docstring-category">Type</span>.</div><div><p>Geometric gene duplication with probability cutoff</p><ul><li><p><code>p</code> : probability cutoff</p></li><li><p><code>ε</code> : distance (set this to 1)</p></li><li><p><code>arrival</code> : node arrival function (:quad, :linear, :exp, :constant)</p></li></ul><p>Przulj, N., Kuchaiev, O., Stevanovic, A., and Hayes, W. (2010). Geometric evolutionary dynamics of protein interaction networks. In Proc. of the Pacific Symposium Biocomputing, pages 4–8.</p></div><a class="source-link" target="_blank" href="https://github.com/vvjn/NetalignUtils.jl/blob/c6e705502cbe0ac61187665fa1fa449dcac3317a/src/generators.jl#L141-L149">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NetalignUtils.SocialNE" href="#NetalignUtils.SocialNE"><code>NetalignUtils.SocialNE</code></a> — <span class="docstring-category">Type</span>.</div><div><p>Social network evolution model</p><ul><li><p><code>λ</code> : node active lifetime</p></li><li><p><code>α, β</code> : how active a node is at adding edges</p></li></ul><p>Leskovec, J., Backstrom, L., Kumar, R., and Tomkins, A. (2008). Microscopic evolution of social networks. In Proc. of the 14th ACM SIGKDD International Conference on Knowledge Discovery and Data Mining, KDD&#39;08, pages 462–470.</p></div><a class="source-link" target="_blank" href="https://github.com/vvjn/NetalignUtils.jl/blob/c6e705502cbe0ac61187665fa1fa449dcac3317a/src/generators.jl#L290-L296">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Random.rand" href="#Base.Random.rand"><code>Base.Random.rand</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">rand([rng::AbstractRNG], gf::GraphGenerator, Ntot::Integer, Tmax::Number, N0::Integer=5)</code></pre><p><strong>Arguments</strong></p><ul><li><p><code>Ntot</code> : total # of nodes</p></li><li><p><code>N0</code> : # of nodes at time 0</p></li><li><p><code>Tmax</code> : end of timespan</p></li></ul><p>Generates a random network depending on the <code>GraphGenerator</code></p></div><a class="source-link" target="_blank" href="https://github.com/vvjn/NetalignUtils.jl/blob/c6e705502cbe0ac61187665fa1fa449dcac3317a/src/generators.jl#L13-L22">source</a></section><h2><a class="nav-anchor" id="Randomization-1" href="#Randomization-1">Randomization</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NetalignUtils.strict_events_shuffle" href="#NetalignUtils.strict_events_shuffle"><code>NetalignUtils.strict_events_shuffle</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">strict_events_shuffle(G::SparseMatrixCSC{Events}, prob::Number)
strict_events_shuffle!(G::SparseMatrixCSC{Events}, prob::Number)</code></pre><ul><li><p><code>prob</code> : <code>0 &lt;= prob &lt;= 1</code></p></li></ul><p>The following does the event shuffle as in page 15/30 of modern temporal network theory a colloquim eur phys j b 2015. After that it merges overlapping events between node pairs. The number of events between node pairs will not be conserved because it merges overlapping events.</p><p>The topology of the resulting network when it is flattened does not change since only the event times are changed.</p></div><a class="source-link" target="_blank" href="https://github.com/vvjn/NetalignUtils.jl/blob/c6e705502cbe0ac61187665fa1fa449dcac3317a/src/randomize.jl#L3-L17">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="NetalignUtils.links_shuffle" href="#NetalignUtils.links_shuffle"><code>NetalignUtils.links_shuffle</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">links_shuffle(G::SparseMatrixCSC{Events}, prob::Number)</code></pre><ul><li><p><code>prob</code> : <code>0 &lt;= prob &lt;= 1</code></p></li></ul><p>Page 16/30 of modern temporal network theory. Rewires each link with probability <code>prob</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/vvjn/NetalignUtils.jl/blob/c6e705502cbe0ac61187665fa1fa449dcac3317a/src/randomize.jl#L58-L65">source</a></section><footer><hr/></footer></article></body></html>
